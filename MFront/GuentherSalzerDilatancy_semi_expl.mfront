
@DSL Implicit;
@Behaviour GuentherSalzerDilatancy_semi_expl;
@Author Thomas Nagel;
@Description {
Günther Salzer model for rock salt.
Semi-explicit treatment of damage/dilatancy.

Günther, R., & Salzer, K. (2012). Advanced strain-hardening approach.
In Mechanical Behaviour of Salt VII (Issue December 2016). 
CRC Press. https://doi.org/10.1201/b12041-4

Günther, R.-M., Salzer, K., Popp, T., & Lüdeling, C. (2015).
Steady-State Creep of Rock Salt: Improved Approaches for Lab Determination 
and Modelling. Rock Mechanics and Rock Engineering, 
48(6), 2603–2613. https://doi.org/10.1007/s00603-015-0839-2
};

@Algorithm NewtonRaphson;
@MaximumNumberOfIterations 100;
//@CompareToNumericalJacobian true;
//@PerturbationValueForNumericalJacobianComputation 1.e-8;
//@JacobianComparisonCriterion 1e-7;

@Epsilon 1.e-14;
@Theta 1.0;

@ModellingHypotheses{".+"};
@Brick StandardElasticity;

@MaterialProperty real Ap;
Ap.setEntryName("PrimaryPowerLawFactor");
@MaterialProperty real np;
np.setEntryName("PrimaryPowerLawExponent");
@MaterialProperty real As1;
As1.setEntryName("SecondaryPowerLawFactor1");
@MaterialProperty real ns1;
ns1.setEntryName("SecondaryPowerLawExponent1");
@MaterialProperty real Q1;
Q1.setEntryName("SecondaryActivationEnergy1");
@MaterialProperty real As2;
As2.setEntryName("SecondaryPowerLawFactor2");
@MaterialProperty real ns2;
ns2.setEntryName("SecondaryPowerLawExponent2");
@MaterialProperty real Q2;
Q2.setEntryName("SecondaryActivationEnergy2");
@MaterialProperty real mup;
mup.setEntryName("HardeningExponent");
@MaterialProperty real epsV0;
epsV0.setEntryName("InitialHardening");
@PhysicalBounds epsV0 in [1e-6:*[; //practical limit
@MaterialProperty real sig0;
sig0.setEntryName("ReferenceStress");

@Parameter real Ru = 8.314472; // J/(Kmol)
Ru.setEntryName("UniversalGasConstant");


@Parameter real D1 = 8.;
@Parameter real D2 = 0.25;
@Parameter real D3 = 4.8;

@Parameter real a1 = 5.e-3;
@Parameter real a2 = 0.0135;
@Parameter real a3 = -0.4;

@Parameter real a4 = 1.e-6;
@Parameter real a5 = 2.5e-4;
@Parameter real a6 = -6.25;

@Parameter real a7 = 0.;
@Parameter real a8 = 5.13;
@Parameter real a9 = -0.3;

//Hardening strain
@StateVariable real epsCrV;
epsCrV.setEntryName("HardeningStrain");

//Dilatancy strain
@StateVariable real eps_vol;
eps_vol.setEntryName("DilatancyStrain");

@AuxiliaryStateVariable stress Udil;
Udil.setEntryName("DilatancyWork");

//Recovery strain increment
@LocalVariable real deps_cr_E;
//Creep strain increment
@LocalVariable Stensor deps_cr;


//! Second Lamé coefficient
@LocalVariable stress mu;
//! First Lamé coefficient
@LocalVariable stress lambda;

@LocalVariable real As1T, As2T, s3_prev, seq_prev, seq_prev_Dil;
@LocalVariable bool Fdil;

@InitLocalVariables {
  mu = computeMu(young, nu);
  lambda = computeLambda(young, nu);
  // Compute initial elastic strain
  eel = 1. / (2. * mu) * sig - nu / young * trace(sig) * Stensor::Id();
  As1T = As1 * std::exp(-Q1 / (Ru * (T + dT)));
  As2T = As2 * std::exp(-Q2 / (Ru * (T + dT)));

  const Stensor eps_prev = eel - deel;
  const Stensor sig_prev =
      lambda * trace(eps_prev) * Stensor::Id() + 2. * mu * eps_prev;
  seq_prev = sigmaeq(sig_prev);
  const auto sig_p = sig_prev.computeEigenValues(Stensor::DESCENDING);
  s3_prev = -sig_p(0); // sign change for compression convention
  seq_prev_Dil = s3_prev * (D1 / (D2 + s3_prev) + D3);

  Fdil = seq_prev - seq_prev_Dil > 0;
}

@Integrator {
  const auto eeps = real(1e-14);
  const auto seps = eeps * young;
  const auto s = deviator(sig);
  const auto seq = sigmaeq(s);
  const auto norm_s = seq / std::sqrt(3. / 2.);

  if (norm_s > seps) {
    constexpr auto Pdev = Stensor4::K();
    const auto A1sig = a1 + a2 * std::exp(a3 * s3_prev);
    const auto A2sig = a4 + a5 * std::exp(a6 * s3_prev);
    const auto A3sig = a7 + a8 * std::exp(a9 * s3_prev);

    // secondary (recovery)
    const auto b =
        As1T * std::pow(seq / sig0, ns1) + As2T * std::pow(seq / sig0, ns2);
    const auto db_dseq = ns1 / sig0 * As1T * std::pow(seq / sig0, ns1 - 1) +
                         ns2 / sig0 * As2T * std::pow(seq / sig0, ns2 - 1);

    deps_cr_E = b * dt;
    const auto epsCrV_new = epsCrV + depsCrV;
    const auto seq_to_np = std::pow(seq / sig0, np);

    fepsCrV = depsCrV -
              dt * (Ap * seq_to_np / std::pow(epsV0 + epsCrV_new, mup)) +
              deps_cr_E + deps_vol;
    dfepsCrV_ddepsCrV =
        1. + dt * mup * Ap * seq_to_np / std::pow(epsV0 + epsCrV_new, mup + 1);
    const auto dfepsCrV_dseq = -dt * (Ap * np * std::pow(seq / sig0, np - 1) /
                                      std::pow(epsV0 + epsCrV_new, mup)) +
                               db_dseq * dt;
    dfepsCrV_ddeel = dfepsCrV_dseq * 3. * s / (2. * seq) * 2. * mu;
    dfepsCrV_ddeps_vol = 1.;
    deps_cr = eval(std::sqrt(3. / 2.) * (depsCrV + deps_cr_E + deps_vol) * s /
                   norm_s);
    feel += deps_cr;
    dfeel_ddepsCrV = std::sqrt(3. / 2.) / norm_s * s;
    dfeel_ddeps_vol = std::sqrt(3. / 2.) / norm_s * s;
    dfeel_ddeel +=
        2. * mu * std::sqrt(3. / 2.) / norm_s *
        ((depsCrV + deps_cr_E + deps_vol) * (Pdev - (s ^ s) / norm_s / norm_s) +
         db_dseq * dt * 3. / (2. * seq) * (s ^ s));

    feps_vol = deps_vol - (A1sig + A2sig * std::exp(A3sig * Udil)) *
                              (seq_prev - seq_prev_Dil) *
                              (depsCrV + deps_cr_E + deps_vol);
    dfeps_vol_ddeps_vol = 1. - (A1sig + A2sig * std::exp(A3sig * Udil)) *
                                   (seq_prev - seq_prev_Dil);
    dfeps_vol_ddepsCrV =
        -(A1sig + A2sig * std::exp(A3sig * Udil)) * (seq_prev - seq_prev_Dil);
    dfeps_vol_ddeel = -(A1sig + A2sig * std::exp(A3sig * Udil)) *
                      (seq_prev - seq_prev_Dil) * dt * db_dseq * 3. * s /
                      (2. * seq) * 2. * mu;
  }
}

@UpdateAuxiliaryStateVariables
{
  // http://tfel.sourceforge.net/tensors.html#eigenvalues-eigenvectors-and-eigentensors-of-symmetric-tensors
  if (seq_prev - seq_prev_Dil > 0.) {
    const auto dUdil =
        (seq_prev - seq_prev_Dil) * (depsCrV + deps_cr_E + deps_vol);
    Udil += dUdil;
  }
}
